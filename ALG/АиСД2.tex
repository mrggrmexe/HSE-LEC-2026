\documentclass[12pt,a4paper]{article}

% --- Русская локализация и кодировки ---
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% --- Поля и верстка ---
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{setspace}
\onehalfspacing

% --- Математика ---
\usepackage{amsmath}
\usepackage{amssymb}

% --- Гиперссылки ---
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black, citecolor=black}

% --- Оформление кода ---
\usepackage{listings}
\lstset{
    inputencoding=utf8,
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\bfseries,
    commentstyle=\itshape,
    stringstyle=\ttfamily,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=8pt,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    columns=fullflexible,
    keepspaces=true,
    extendedchars=true
}

% --- Списки ---
\usepackage{enumitem}
\setlist{nosep}

% --- Графика (опционально, для схем) ---
\usepackage{tikz}
\usetikzlibrary{trees}

\title{ФКН ВШЭ АиСД 2026\\[4pt]
{\large хеширование. Устройство хеш-таблиц.}}
\author{ФИО: \underline{\hspace{4cm} Штукмайстер Г.П.}}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Зачем нужно хеширование и где оно используется}

Во многих практических приложениях требуется структура данных, реализующая операции
\textbf{ADT Словарь}:
\begin{itemize}
    \item \texttt{INSERT(object)}
    \item \texttt{SEARCH(object)}
    \item \texttt{DELETE(object)}
    \item \texttt{UPDATE(object)}
\end{itemize}
Хеш-таблица в среднем обеспечивает константное время всех этих операций (амортизированно),
в отличие от массива/списка (линейное) и сбалансированных деревьев (логарифмическое).

\section{Хеш-функции и \texttt{std::hash}}

\subsection{Что такое хеш-функция}
\textbf{Хеш-функция} отображает ключ (или объект) в целое число фиксированной разрядности (часто \texttt{size\_t}),
которое затем превращается в индекс в таблице размера $M$:
\[
\text{index} = h(key) \bmod M
\]
Идеально хочется равномерного распределения значений и очень малой вероятности коллизий.

\subsection{\texttt{std::hash} в стандартной библиотеке}
Стандартная библиотека C++ предоставляет шаблон \texttt{std::hash<T>}:
\begin{itemize}
    \item имеет специализации для фундаментальных типов (\texttt{bool, char, int, long, float, double, ...});
    \item возвращает \texttt{std::size\_t};
    \item не должен бросать исключения (\texttt{noexcept});
    \item детерминированен: один и тот же вход $\rightarrow$ один и тот же результат;
    \item внутренняя реализация зависит от платформы/компилятора:
    для чисел часто тождественное отображение, для строк — быстрые некриптографические хеши
    (упоминается MurmurHash), указатели могут приводиться к \texttt{size\_t}.
\end{itemize}

\subsection{Пример: пользовательский тип и свой хеш}
Чтобы хранить пользовательский тип в \texttt{unordered\_map/unordered\_set}, нужны:
\begin{enumerate}
    \item \texttt{operator==} (или предикат равенства),
    \item специализация \texttt{std::hash}.
\end{enumerate}

\begin{lstlisting}[language=C++,caption={Пример специализации std::hash для пользовательского типа}]
#include <string>
#include <functional>

struct Person {
    std::string firstName;
    std::string lastName;
};

inline bool operator==(const Person& lhs, const Person& rhs) {
    return lhs.firstName == rhs.firstName && lhs.lastName == rhs.lastName;
}

template<>
struct std::hash<Person> {
    std::size_t operator()(const Person& s) const noexcept {
        std::size_t h1 = std::hash<std::string>{}(s.firstName);
        std::size_t h2 = std::hash<std::string>{}(s.lastName);
        return h1 ^ (h2 << 1);
    }
};
\end{lstlisting}

\section{Коллизии и два подхода к адресации}

Если разные ключи дают один и тот же индекс, возникает \textbf{коллизия}.
Есть два классических метода борьбы с коллизиями:
\begin{itemize}
    \item \textbf{Закрытая адресация (separate chaining, метод цепочек)}:
    в каждой ячейке таблицы хранится структура (обычно список) элементов с одинаковым индексом.
    \item \textbf{Открытая адресация (probing, пробирование)}:
    элементы хранятся прямо в массиве, а при занятости ячейки выполняется поиск следующей по правилу.
\end{itemize}

\section{Закрытая адресация: метод цепочек (separate chaining)}

\subsection{Идея}
Хеш-таблица — это массив $M$ «бакетов», каждый бакет содержит цепочку элементов:
\[
\text{table}[i] \rightarrow (k_1, v_1) \rightarrow (k_2, v_2) \rightarrow \dots
\]
В лекции иллюстрируется пример «хеширования доменных имён» (берём, например,
последние три бита первого символа) и получаем бакеты 0..7, где в каждом образуется цепочка.

\subsection{Коэффициент заполненности (load factor)}
Пусть:
\begin{itemize}
    \item $n$ — число элементов,
    \item $M$ — число бакетов (размер массива).
\end{itemize}
Тогда классический коэффициент заполненности:
\[
\alpha = \frac{n}{M}
\]
В примере со слайдов при $n=18$, $M=8$ получаем $\alpha = 2.25$, и это сильно ухудшает среднюю сложность
операций (цепочки становятся длинными).

Также на слайдах вводится коэффициент по числу \textit{занятых ячеек}:
\[
\alpha^* = \frac{\text{occupied}}{M}
\]
В случае цепочек при «забитости всех бакетов» может быть $\alpha^*=1$ даже при большом $n$.

\subsection{Перехеширование (rehashing)}
Если $\alpha$ превышает порог (на слайдах как пример упоминается порог вроде $\alpha=5$), выполняют \textbf{rehashing}:
\begin{itemize}
    \item увеличивают размер таблицы: обычно $M \leftarrow 2M$,
    \item изменяют хеш-функцию под новый размер,
    \item заново вставляют все элементы в новую таблицу.
\end{itemize}

\subsection{Слабости метода цепочек}
На слайдах подчёркиваются проблемы:
\begin{itemize}
    \item нужна дополнительная память под связные списки (узлы, указатели);
    \item операции деградируют до операций на списках при больших цепочках (плохое распределение/большая $\alpha$).
\end{itemize}
Иногда задаются вопросом: «почему не использовать вместо списков сбалансированные деревья?»
(в практических реализациях такое встречается, но это отдельная тема).

\section{Открытая адресация: пробирование (probing)}

\subsection{Идея}
Все элементы хранятся прямо в массиве размера $M$.
Если базовая позиция занята, строим последовательность проб (просматриваемых индексов) до тех пор,
пока не найдём нужный элемент или свободную ячейку.

\subsection{Линейное пробирование}
Правило проб:
\[
\text{bin}(k) = (h(key) + k) \bmod M,\quad k=0,1,2,\dots
\]
Псевдокод вставки (идея со слайдов):
\begin{lstlisting}[language=C++,caption={INSERT при линейном пробировании (схема)}]
size_t initial = hash(obj.hash(), M);
for (size_t k = 0; k < M; ++k) {
    size_t bin = (initial + k) % M;
    if (!occupied[bin]) {
        table[bin] = obj;
        occupied[bin] = true;
        break;
    }
}
\end{lstlisting}

\subsection{Поиск (SEARCH) и условия остановки}
При \texttt{SEARCH(object)} мы просматриваем те же ячейки, что и при вставке:
\begin{itemize}
    \item нашли объект $\Rightarrow$ успех;
    \item нашли пустую ячейку $\Rightarrow$ объект точно отсутствует;
    \item просмотрели весь массив при $\alpha^* = 1$ $\Rightarrow$ объект отсутствует (но это уже плохой режим).
\end{itemize}

\subsection{Удаление (DELETE) и проблема «физического удаления»}
Ключевое наблюдение со слайдов: при линейном пробировании \textbf{нельзя просто очистить ячейку},
иначе «разорвётся» цепочка проб и некоторые элементы станут недостижимыми при поиске.

\paragraph{Ленивое удаление (lazy deletion).}
Вводят третий статус ячейки \texttt{ERASED}:
\begin{itemize}
    \item при поиске считать \texttt{ERASED} как «занято» (продолжаем пробирование),
    \item при вставке считать \texttt{ERASED} как «пусто» (можно вставлять).
\end{itemize}

\subsection{Кластеризация}
Линейное пробирование вызывает \textbf{первичную кластеризацию}:
образуются длинные подряд идущие блоки занятых ячеек, которые ухудшают время операций.

\subsection{Оценки среднего числа проб (линейное пробирование)}
Пусть $\alpha^*$ — доля занятых ячеек.
Для линейного пробирования на слайдах приведены оценки среднего числа проб:
\[
E[\text{probes} \mid \text{successful}] =
\frac12\left(1+\frac{1}{1-\alpha^*}\right)
\]
\[
E[\text{probes} \mid \text{unsuccessful / insert}] =
 \frac12\left(1+\frac{1}{(1-\alpha^*)^2}\right)
\]
Вывод: при $\alpha^* \to 1$ ожидание стремится к бесконечности.

\subsection{Как бороться с деградацией}
На слайдах перечислены идеи:
\begin{itemize}
    \item брать очень большой размер таблицы, чтобы не доходить до высокой заполненности;
    \item контролировать заполненность через \textbf{rehashing};
    \item использовать другие стратегии сдвига: квадратичное и двойное пробирование.
\end{itemize}

\section{Квадратичное пробирование (quadratic probing)}

\subsection{Правило проб}
Общий вид (идея): 
\[
\text{bin}(k) = \bigl(h(key) + c_1 k + c_2 k^2\bigr) \bmod M
\]
Цель — уменьшить первичную кластеризацию, но появляется \textbf{вторичная кластеризация}:
если два ключа попали в одну стартовую ячейку, они будут следовать по одной и той же последовательности проб.

\subsection{Практические нюансы из лекции}
На слайдах подчёркнуто:
\begin{itemize}
    \item часто требуется выбирать $M$ простым числом, чтобы гарантировать посещение достаточного числа ячеек;
    \item нельзя так просто пользоваться побитовыми трюками (\texttt{\& (M-1)}) и приходится считать \texttt{\% M};
    \item при rehashing нужно уметь находить следующее простое число после $2M$.
\end{itemize}

\subsection{Оценки среднего числа проб (квадратичное пробирование)}
Для заполненности $\alpha^*$ на слайдах приведены формулы:
\[
E[\text{probes} \mid \text{successful}] =
\frac{\ln\left(\frac{1}{1-\alpha^*}\right)}{\alpha^*}
\]
\[
E[\text{probes} \mid \text{unsuccessful / insert}] =
\frac{1}{1-\alpha^*}
\]

\subsection{Сравнение с линейным пробированием}
В лекции есть численный пример при $\alpha^* = 0.9$:
\begin{itemize}
    \item линейное пробирование: успешный поиск $\approx 5.5$, вставка/неуспешный поиск $\approx 50.5$;
    \item квадратичное пробирование: успешный поиск $\approx 2.56$, вставка/неуспешный поиск $\approx 10$.
\end{itemize}
Вывод: квадратичное пробирование заметно устойчивее при высокой заполненности.

\section{Двойное хеширование (double hashing)}
При двойном хешировании шаг пробирования вычисляется второй хеш-функцией:
\[
\text{bin}(k) = \bigl(h_1(key) + k \cdot h_2(key)\bigr) \bmod M
\]
Интуитивно это «размешивает» траектории проб и помогает бороться с кластеризацией.

\section{Идеальное (perfect) хеширование без коллизий}

\subsection{Когда применимо}
Идеальное хеширование разумно применять для \textbf{статичных наборов данных}:
множество ключей известно заранее и почти не меняется.

\subsection{Двухуровневая схема (общая идея)}
Лекция показывает пример двухуровневого построения:
\begin{enumerate}
    \item \textbf{Шаг 1.} Случайно выбрать универсальную хеш-функцию и разложить ключи по $M$ бакетам.
    \item \textbf{Шаг 2.} На первом уровне можно использовать метод цепочек, получая наборы ключей в бакетах.
    \item \textbf{Шаг 3.} Для каждого бакета $i$ с $k_i$ ключами строится \textbf{вторая} таблица размера $k_i^2$
    и подбирается своя хеш-функция так, чтобы внутри бакета не было коллизий.
\end{enumerate}
Ключевой эффект: при правильном выборе универсального семейства хеш-функций можно добиться того,
что суммарная память на второй уровень остаётся разумной, а поиск работает за $O(1)$ в худшем случае.

\section{Резюме лекции}
\begin{itemize}
    \item Хеш-таблица с закрытой/открытой адресацией реализует интерфейс \textbf{ADT Словарь}.
    \item При закрытой адресации ключевую роль играет коэффициент заполненности $\alpha=n/M$ и rehashing.
    \item При открытой адресации важна стратегия пробирования и работа с удалением (часто через \texttt{ERASED}).
    \item Линейное пробирование страдает первичной кластеризацией; квадратичное уменьшает её, но имеет вторичную.
    \item Двойное хеширование использует вторую хеш-функцию для шага пробирования.
    \item Perfect hashing (двухуровневая схема) подходит для статических наборов данных и даёт поиск без коллизий.
\end{itemize}

\end{document}