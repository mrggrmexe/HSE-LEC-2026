\documentclass[12pt,a4paper]{article}

% --- Русская локализация и кодировки ---
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% --- Поля и верстка ---
\usepackage{geometry}
\geometry{margin=2.5cm}
\usepackage{setspace}
\onehalfspacing

% --- Математика ---
\usepackage{amsmath}
\usepackage{amssymb}

% --- Гиперссылки ---
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black, citecolor=black}

% --- Оформление кода ---
\usepackage{listings}
\usepackage{listingsutf8}
\lstset{
    inputencoding=utf8,
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\bfseries,
    commentstyle=\itshape,
    stringstyle=\ttfamily,
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=8pt,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    columns=fullflexible,
    keepspaces=true,
    extendedchars=\true
}

% --- Списки ---
\usepackage{enumitem}
\setlist{nosep}

% --- Графика (опционально, для схем) ---
\usepackage{tikz}
\usetikzlibrary{trees}

\title{ФКН ВШЭ АиСД 2026\\[4pt]
\large Хеширование. Хеш-функции и их свойства}
\author{ФИО: \underline{\hspace{4cm} Штукмайстер Г.П.}}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

\section{Оценивание}
\begin{center}{0.45\%НАКОП+0.2\%ПР+0.35\%ЭКЗАМЕН}\end{center}

\section{Цель курса}
Развитие навыков анализа сложности
алгоритмов, работающих с различными
структурами данных, и их применение
для разработки программных решений.

\section{Задача хранения неупорядоченных данных}
\subsection{Простой обработчик ошибок}
- Каждой ошибке присвоен 8-битный код [0..255]. \\
- Каждая ошибка обрабатывается внутри специальной функции. \\
НЕДОСТАТОК: Долгое время работы логарифмической сложности. \\
БЫСТРЫЙ ДОСТУП: Прямая индексация.

\subsection{связывание IP-адреса и домена}
- в рамках организации IP-адреса компьютеров сотрудников начинаются с 129.97 \\
- требуется организовать хранение IP-адресов и связанных с ними доменных имен \\
ИТОГ: различных IP-адресов, которые определяются последними двумя байтами, всего существует 65536.

\subsection{Хранение результатов экзамена}
- Процесс отображения объекта на целое число в диапазоне [0..M-1] называется хешированием. \\ 
- Несколько объектов могут получить один и тот же хеш — коллизия. \\
- хеш-таблицы используют хеш-функцию вместе с некоторым механизмом обработки коллизий \\
- Важно: хеширование не гарантирует уникальность индексов, поэтому обработка коллизий является частью конструкции хеш-таблицы.

\section{Два основных этапа процесса хеширования}
В лекции хеширование рассматривается как двухэтапный процесс отображения множества объектов на множество индексов:
\begin{enumerate}
    \item \textbf{Hash(Object)}: быстрый расчет некоторого большого целочисленного значения (часто 32-битного) по объекту.
    \item \textbf{Mapping Down}: перевод полученного значения в индекс массива размера $M$, то есть в диапазон $[0..M-1]$.
\end{enumerate}
Итого: \textbf{объект} $\rightarrow$ (целое число) $\rightarrow$ \textbf{индекс}. \cite{ } % оставлено намеренно пустым

\section{Хеш-функция и желаемые свойства}
Пусть $hash(x)$ — функция, отображающая объект в целое число. Ключевые свойства:
\begin{enumerate}
    \item \textbf{Быстрота}: вычисляется за $\Theta(1)$.
    \item \textbf{Детерминированность}: один и тот же объект всегда дает один и тот же хеш.
    \item \textbf{Согласованность с равенством}: если $x = y$, то $hash(x)=hash(y)$.
    \item \textbf{Низкая вероятность коллизии}: для разных объектов $x \neq y$ вероятность $hash(x)=hash(y)$ должна быть малой.
\end{enumerate}

\section{Примеры (и анти-примеры) хеширования объектов}
\subsection{Хеширование с помощью явного идентификатора}
Идея: хранить в объекте явный счетчик/ID и возвращать его как хеш.
\begin{itemize}
    \item Плюс: каждый объект получает уникальный хеш.
    \item Минус: \textbf{одинаковые по смыслу объекты} могут получить \textbf{разные} хеши (нарушение ожидаемой семантики равенства при поиске).
\end{itemize}

\subsection{Хеширование по адресу в памяти}
Идея: $hash(x) = reinterpret\_cast<size\_t>(this)$.
\begin{itemize}
    \item Плюс: быстро, часто уникально среди живых объектов.
    \item Минус: одинаковые объекты (по данным) будут иметь разные адреса $\Rightarrow$ разные хеши.
\end{itemize}

\subsection{Арифметическое хеширование на примере рациональных чисел}
Пусть объект — дробь $numer/denom$. Можно строить хеш как линейную комбинацию полей:
\[
hash(numer, denom) = numer + C \cdot denom
\]
где $C$ — некоторое большое число.
Замечания:
\begin{itemize}
    \item Нужно привести дробь к каноническому виду (например, делить числитель и знаменатель на $\gcd$), иначе $1/2$ и $2/4$ будут разными объектами и дадут разные хеши.
    \item Даже при канонизации коллизии возможны: разные дроби могут давать одинаковое значение хеша (это принципиально неизбежно при конечном диапазоне хеша).
\end{itemize}

\section{Плохие хеш-функции (типовые проблемы)}
\begin{itemize}
    \item \textbf{Слишком медленная хеш-функция}: например, $\Theta(n)$ по длине строки без необходимости.
    \item \textbf{Потеря порядка символов}: если хеш зависит только от мультимножества символов, то анаграммы дают одинаковый хеш.
    \item \textbf{Плохое распределение}: множество разных объектов попадает в малое число значений $\Rightarrow$ много коллизий.
    \item Даже если «ускорили» до $\Theta(\log n)$, все равно может быть неприемлемо; и такие функции обычно нельзя использовать в криптографии.
\end{itemize}

\section{Mapping Down: как получить индекс в $[0..M-1]$}
Пусть на первом этапе мы получили некоторое целое число $key$ (например, 32-битное). Нужно вычислить индекс в массиве размера $M$.

\subsection{Простой способ: операция \texttt{mod}}
\[
hash_M(key) = key \bmod M
\]
Замечание из лекции: деление (и взятие остатка) — относительно дорогая операция. Поэтому часто выбирают $M = 2^m$.

\subsection{Если $M = 2^m$: извлечение младших битов}
При $M=2^m$ вычисление $key \bmod 2^m$ эквивалентно извлечению $m$ младших битов:
\[
key \bmod 2^m = key\ \&\ (2^m - 1)
\]
Это реализуется побитовыми операциями \texttt{\&}, \texttt{<<}, \texttt{>>}.

\paragraph{Минус mod при $M=2^m$.}
Индекс полностью определяется младшими разрядами ключа, а старшие биты не влияют на результат.

\subsection{Мультипликативный метод}
Идея: «перемешать» биты ключа умножением на константу $C$, а затем взять средние/нужные биты.
Типовая форма (для $M=2^m$):
\[
hash_M(key) = \big((C \cdot key) \gg shift\big)\ \&\ (2^m - 1)
\]
где $shift$ подбирается так, чтобы извлекать нужные $m$ бит.

\paragraph{Пример из лекции.}
При $m=10$ и $key=42$ (и соответствующем $shift$) получается:
\[
hash_M(42, 10) = 195.
\]
Смысл: в формировании итогового индекса начинают участвовать \textbf{все} разряды ключа, а не только младшие.

\section{Фиксированная вероятность коллизий и универсальное хеширование}
Обозначим:
\begin{itemize}
    \item $U$ — множество возможных ключей (универсум),
    \item $M$ — число ячеек (размер таблицы),
    \item $\mathcal{H}$ — семейство хеш-функций $h: U \to [0..M-1]$.
\end{itemize}

\subsection{Определение универсального семейства}
Семейство $\mathcal{H}$ называется \textbf{универсальным}, если для любых $x \neq y$ вероятность коллизии (при равновероятном выборе $h \in \mathcal{H}$) ограничена сверху:
\[
\Pr_{h \in \mathcal{H}}[h(x)=h(y)] \le \frac{1}{M}.
\]
Интуиция: мы «фиксируем» вероятность коллизии на уровне порядка $1/M$ для любых двух разных ключей.

\subsection{Как построить универсальное семейство (шаги из лекции)}
\begin{enumerate}
    \item Выбрать простое число $M$ (размер таблицы).
    \item Разбить ключ $key$ на разряды (блоки) по основанию $M$:
    \[
    key = \langle k_0, k_1, \dots, k_r \rangle,\quad k_i \in [0, M).
    \]
    \item Случайно выбрать коэффициенты:
    \[
    a = \langle a_0, a_1, \dots, a_r \rangle,\quad a_i \in [0, M).
    \]
    \item Определить хеш-функцию как скалярное произведение по модулю $M$:
    \[
    hash_M(key) = \left(\sum_{i=0}^{r} a_i \cdot k_i\right)\bmod M.
    \]
\end{enumerate}

\subsection{Пример: IP-адреса}
Если нужно хранить порядка 500 IP-адресов, можно взять простое $M=997$.
IP естественно представляется как 4 разряда:
\[
IP=\langle x_1, x_2, x_3, x_4\rangle.
\]
Выбираем коэффициенты, например $a=\langle 43, 37, 371, 133\rangle$, тогда:
\[
hash_{997}(IP)= (43x_1 + 37x_2 + 371x_3 + 133x_4)\bmod 997.
\]

\section{Идеальное хеширование}
\textbf{Идеальное хеширование} (perfect hashing) — подход, который для \textbf{фиксированного} (статичного) множества ключей позволяет полностью исключить коллизии.
Обычно это достигается специальной конструкцией (часто двухуровневой) и применяется, когда набор ключей известен заранее.

\section{Резюме лекции}
\begin{enumerate}
    \item Хеширование — двухэтапный процесс: \textit{Hash(Object)} и \textit{Mapping Down}.
    \item Есть разные способы построения хеш-функций и способы \textbf{зафиксировать} вероятность коллизий (универсальное хеширование).
\end{enumerate}

\section{Что будет на практике / в следующей лекции (тизер)}
\begin{itemize}
    \item Практические вопросы хеширования целых чисел и строк.
    \item Приемы: хеширование с солью, хеширование сложных объектов со \texttt{std::hash}.
    \item ADT «Словарь»: реализация хеш-таблиц с открытой/закрытой адресацией, обработка коллизий, идеальное хеширование для статичных данных.
\end{itemize}




\end{document}
